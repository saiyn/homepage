---
layout: post
title:  "Gpu相关笔记"
date:   2017-03-2５ 15:15:54
categories: Diary
excerpt: gpu linux mesa x11 display
---

* content
{:toc}


记录开发中和平时学习总结的关于GPU方面的知识。

---

## linux下GPU架构的演变

理解一项技术、一个软件框架，从了解其发展历程着手可以对理解其技术细节有非常大的帮助。了解技术背后的文化往往比单纯已经技术本身重要很多。

### X11的内部架构

![x11_inf](http://omp8s6jms.bkt.clouddn.com/image/git/x11_infras.png)

DIX - Device-Independennt X
DDX - Device-Dependent X

### DRI/DRM 内部架构

一开始，linux下只有XFree86 server会去直接访问显卡，所有当时的设计很简单，XFree86以特权模式运行，可以直接在用户层访问显卡硬件，而不需要linux内核的支持进行2D加速。这样的设计的好处就是架构非常的简单，从而使XFree86 server进行不同操作系统的移植非常的方便。

后来，第一个对立与硬件的3D加速器Utah-GLX合入了linux中。和之前的2D驱动一样，这个3D软件也是在用户层直接访问显卡硬件。

与此同时，framebuffer驱动架构模型渐渐得到广泛应用，它代表的是另一种模拟直接访问显卡硬件的组件。由于多了framebuffer这样的和XFree86 Server可能同时竞争访问显卡硬件资源的组件，内核中引入了VT switchs。它会通过内核向X server发送信号告诉x derver去保存一下当前的显卡状态数据。因为多了这样的几张上，导致显驱动的开发不再那么简单，而是变得bug百出。


![fb_on](http://omp8s6jms.bkt.clouddn.com/image/git/fb_on.png)

上图就是早期linux下的graphics stack。显然，这种模型是有缺陷的。首先，它要求授予用户层的应用程序特权去直接访问硬件的设备。其次，所有的GL加速必须通过X 协议间接的实现，这使得加速效果大打折扣。这对于那些数据密集的功能如3D纹理加载影响很大。由于大家更加关注linux下的安全性和性能，必须得设计新的模型替代上面的架构。

于是引出了DRI模块，这个模块依赖于在内核中的一个负责检查3D命令流的正确性和安全性的组件。加入这个组件后，原来直接访问底层硬件的程序现在改成向该组件发送command buffers来实现间接访问。这个架构还只是针对与3D引擎的，2D引擎和之前一样仍然通过拥有超级用户权限的应用程序来访问底层硬件。

![dri](http://omp8s6jms.bkt.clouddn.com/image/git/dri.png)

目前实际的架构是为了满足一些新的需求。首先，要解决X server使用超级用户权限带来的安全性问题。其次，解决之前设计中不同驱动竞争同一硬件带来的问题。要解决这些问题，需要完成两个部分的.1)将内核中framebuffer的功能合入到DRM模块中；2)让X.Org通过非特权模式访问DRM模块来间接访问显卡硬件。这就是所谓的KMS(Kernel Modesetting)架构。在这个架构中，DRM模块负责为framebuffer和X.org通过modesetting 服务。

![new_stack](http://omp8s6jms.bkt.clouddn.com/image/git/new_mo.png)



---

## GTT

工作中刚接触到GPU相关内容时，经常看到听到关于GTT的概念。单纯研究理解GTT的概念可能不是很好懂，有时候我们需要跳出问题本身而`站的高一点`来看问题就容易理解很多。
所以我们先研究显卡显存的管理机制。

显卡使用的内存分为两部分，一部分是显卡自身集成的内存叫做`VRAM`,另一部分是使用系统的内存。所谓的集成显卡就是没有自身内存而完全使用系统内存的显卡。因为访问显存的速度显然要比访问系统内存快很多，所以高端游戏笔记本独显是基本配置。对于即要使用自身显存，又要使用系统内存的显卡，如何管理这两种内存，就引出了GTT的概念。因为显卡如果要想使用系统内存，肯定得申请，而且一般需要的内存基本上是大于512M的大快内存，如果让内核一次性分配连续的这么大的内存给显卡使用肯定是不可能的，因为者会造成很大的浪费。所以显存必须按需向系统申请内存。这样显卡得到的系统内存肯定是不连续的。而显卡自身的内存一般是连续的。对于管理这两种内存，最简单的方法就是统一编址(这类似与RISC机器上IO和内存统一遍址)。统一编址管理不连续的内存，显然就得建立内存页表进行映射。所有GTT全称正是:graphics address remapping table.说白了，GTT就是显卡中用于管理系统内存的一种机制，和系统自身所使用的页表映射非常类似。



---


















