---
layout: post
title:  "C++ 学习笔记"
date:   2015-12-25 15:15:54
categories: Language
excerpt: C++
---

* content
{:toc}



---

# 基础知识

<br />

## const修饰类成员函数

<br />

把一个成员函数声明为const可以保证成员函数不修改类的数据成员，但是，如果该类含有指针，那么在const成员函数中就能修改所指的对象，因为编译器检测不到
这种错误。

	#include <cstring>
	
	class Text{
		public:
			void bad(const string &parm) const;
		private:
			char *_text;
	};
	
	
	void Text::bad(const string &parm) const
	{
		_text = parm.c_str();  //错误：不能修改_text
		
		for(int ix = 0; ix < parm.size(); ++ix)
			_text[ix] = parm[ix];  //不好的风格，但是ok的
	}
	
这个问题可以联想到c语音中const的使用:

	const char *p = "saiyn"; 
	const char * const q = "love bq";
	
	p = "it's ok";
	*p = 'w'; // 错误，不能修改p指向内存块的内容
	
	q = "it's wrong"; //错误，不能修改q的地址
	*q = 'w'; //错误
	
	
上面代码中，对于变量p, 它本身的地址是可以修改的，也就是说可以修改p指向其他内存地址；而对于变量q,它本身的地址和它指向的内存块都不可以被修改。
可见，c++中的这个const修饰效果和上面第二行地二个const修饰效果是一样的。

const成员函数的另外一个特性是，它可以被**相同参数表**的非const成员函数重载:

	class screen{
		public:
			char get(int x, int y);
			char get(int x, int y) const;
			...
	};
	
在这种情况下，类对象的常量性决定了调用哪个函数:

	int main(){
		const screen cs;
		screen s;
		
		char ch = cs.get(0,0); // 调用const成员
		ch = s.get(0,0); //调用非const成员
	}
	


---

<br />

# 特性

<br />

## Rvalue Reference

<br />

c++11中引入了右值的概念，所谓右值，最简单的理解就是凡是无法使用`&`取得其地址的都是rvalue，比如下面代码:

	int a = 1;
	
我们可以通过`&a`取得变量a的地址，而无法通过`&1`取得常量的地址，所以，这里的a就是左值(lvalue),1就是右值(rvalue)。另外一个常见的右值，也是
c++11引入右值概念主要针对的,比如如下代码:

	int getData()
	{
		return 9;
	}

getData()就是一个右值。相对于

	int & lref = a;

这样定义一个左值引用，我们可以使用`&&`定义一个右值引用

	int && rref = getData();
	
下面通过实例代码来解析，c++11中引入右值概念主要解决的Temporary Objects问题。

	class Container{
		int *m_data;
		
	public:
		Container(){
			m_data = new int[20];
		}
		
		~Container(){
			if(m_data){
				delete[] m_data;
				m_data = NULL;
			}
		}
		
		Container(const Container &obj){
			m_data = new int[20];
			
			for(int i = 0; i < 20; i++){
				m_data[i] = obj.m_data[i];
			}
		}
		
	};
	
	

上面Container类的default constructor和copy constructor都需要调用new在堆上分配内存

	Container getContainer()
	{
		Container obj;
		
		return obj;
	}


	int main()
	{
		std::vector<Container> vec;
		
		vec.push_back(getContainer());
		
		return 0;
	}
	
在上面代码的执行中，我们发现，为了向vector中放入一个container对象，我们需要

* 在getContainer()函数中调用default constructor。

* 在调用push_back时，需要调用copy constructor。

这样我们在堆上创建了两个对象，并且最后只用到了一个，另外一个临时对象(Temporary Object)的创建很浪费。为此，右值特性派上用场了。原理就是
使用Rvalue Reference 和 move constructor。

	class Container{
		int *m_data;
		
	public:
		Container(){
			m_data = new int[20];
		}
		
		~Container(){
			if(m_data){
				delete[] m_data;
				m_data = NULL;
			}
		}
		
		Container(const Container &obj){
			m_data = new int[20];
			
			for(int i = 0; i < 20; i++){
				m_data[i] = obj.m_data[i];
			}
		}
		
		Contailer(Contailer && obj)
		{
			//just copy the pointer
			m_data = obj.m_data;
			
			obj.m_data = NULL;
		}
		
	};


这样当我们只需vec.push_back(getContainer())时，move constructor就会被调用，避免了创建临时对象以及内存拷贝。

<br />

**std::move**

std::move的作用是将一个左值引用强制转换为右值引用，比如

	Container a;
	
	Container b = a; //调用copy constructor

	Container c = std::move(a); //调用move constructor

但是这时，需要思考的一个问题时，强制使用move constructor后，会不会导致改变a对象内部数据时同时也就改掉了c对象中的数据？


	
	


	




<br />

## std::bind

<br />

std::bind是一个标准的函数对象，充当功能适配器(Functioanl Adaptor)。

### 应用实例

<br />

使用std::bind的功能可以实现在基类中动态绑定派生类定义的callback函数，这个功能在c++98中是无法实现的。

	#include <iostream>

	class base {
	private:
	    std::function<void (int)> action;
	protected:
	    virtual void onDataBaseReady(int i) { std::cout << i << std::endl; }
	public:
	    void call() {
		action(10);
	    }

	    base() {
		action = std::bind(&base::onDataBaseReady, this, _1);
	    }
	};

	class child : public base {
	protected:
	    virtual void onDataBaseReady(int i) { std::cout << i+10 << std::endl; }
	};

	int main()
	{
	    static child c;
	    c.call();
	    std::cin.get();
	    return 0;
	}


onDataBaseReady是我们可以在不同派生类定义的不同的函数，在基类中通过`action = std::bind(&base::onDataBaseReady, this, _1)`,绑定了
派生类中定义的函数，乍一看，我们绑定的回调函数好像是base::onDataBaseReady,那为什么最终会绑定到派生类的函数内。这是因为我们通过`&base::onDataBaseReady`
传递的是基类虚函数的指针，而我们知道，在通过指针或者引用访问虚函数时，会发生override的，所以最终会调用到我们定义派生类定义的函数。


<br />

## lambda表达式

<br />

在C++ 11中，lambda表达式是一种在被调用的位置或作为参数传递给函数的位置定义匿名函数对象的简便方法。

下图显示了lambda的组成部分：


![cplusplus_0](https://raw.githubusercontent.com/saiyn/homepage/gh-pages/images/cplusplus_0.png)

<br />

1. capture子句，在c++规范中也称为lambad引导。

2. 参数列表(可选)。

3. 可变规范(可选)。

4. 异常规范(可选)。

5. 尾随返回类型(可选)。

6. lambda主体。


---

<br />

# Multithreading

<br />

## 






















