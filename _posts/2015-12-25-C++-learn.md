---
layout: post
title:  "C++ 学习笔记"
date:   2015-12-25 15:15:54
categories: C++
excerpt: C++
---

* content
{:toc}



---

# 基础知识

<br />

## const修饰类成员函数

<br />

把一个成员函数声明为const可以保证成员函数不修改类的数据成员，但是，如果该类含有指针，那么在const成员函数中就能修改所指的对象，因为编译器检测不到
这种错误。

	#include <cstring>
	
	class Text{
		public:
			void bad(const string &parm) const;
		private:
			char *_text;
	};
	
	
	void Text::bad(const string &parm) const
	{
		_text = parm.c_str();  //错误：不能修改_text
		
		for(int ix = 0; ix < parm.size(); ++ix)
			_text[ix] = parm[ix];  //不好的风格，但是ok的
	}
	
这个问题可以联想到c语音中const的使用:

	const char *p = "saiyn"; 
	
	const char * const q = "love bq";
	
	p = "it's ok";
	*p = 'w'; // 错误，不能修改p指向内存块的内容
	
	q = "it's wrong"; //错误，不能修改q的地址
	*q = 'w'; //错误
	
	
上面代码中，对于变量p, 它本身的地址是可以修改的，也就是说可以修改p指向其他内存地址；而对于变量q,它本身的地址和它指向的内存块都不可以被修改。
可见，c++中的这个const修饰效果和上面第二行地二个const修饰效果是一样的。

const成员函数的另外一个特性是，它可以被**相同参数表**的非const成员函数重载:

	class screen{
		public:
			char get(int x, int y);
			char get(int x, int y) const;
			...
	};
	
在这种情况下，类对象的常量性决定了调用哪个函数:

	int main(){
		const screen cs;
		screen s;
		
		char ch = cs.get(0,0); // 调用const成员
		ch = s.get(0,0); //调用非const成员
	}
	


	

























