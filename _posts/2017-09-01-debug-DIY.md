---
layout: post
title:  "调试技术之自制内存调试工具"
date:   2017-09-01 15:15:54
categories: debug
excerpt: debug linux wrap
---

* content
{:toc}

多年的实际工作经历表明，相比于设计和实现代码，调试代码的时间占工作时间的大部分。尤其是运气不好时，需要替别人擦屁股时，更是需要消耗大量时间去调试bug解决问题。

《The Art of Unix Programming》中有这么一段话，c和c++的中心问题在于它们要求程序员自己完成内存管理－－声明变量、显式管理链表、设置缓冲大小、检测或者防止缓冲区溢出，以及分配和回收动态存储。c的内存管理是复杂性和错误的渊源。对于处理复杂数据结构的程序而已，有研究估计**30%~40%的开发时间都用于存储管理**。这个估计甚至还没有包含对调试成本的影响。

所以现在工作中经常出现的情况时，一个bug花了几天甚至一周的时间进行定位，最终通过修改几行甚至是一行代码解决了问题。基于这些事实，提高自己的调试技术水平对于工作效率是至关重要的。**工欲善其事必先利其器**，掌握各种调试工具是立足之本，而自制调试工具往往比使用开源工具简单快速，最主要是部署方便。

本章主要介绍基于wrap通用函数库glibc中的malloc/free等动态内存管理的机制，实现一些工作中常用的定位内存问题的工具。

## malloc/free wrap的实现

ld链接器选项的`--wrap,func`用于实现在静态链接时，func符号的链接地址由func函数变成`__wrap_func`函数地址。于是，当我们自己实现`__wrap_malloc`和`__wrap_free`函数后，通过添加链接参数`-LFLAGS+= -Wl,--wrap,malloc -Wl,--wrap,free`,就可以实现代码中所有调用malloc/free的地方最终实际上调用的是我们实现的`__wrap_malloc/__wrap_free`函数。


上面的编译选项`-Wl,<option>`其实是gcc的编译选项，它的作用是将`<option>`传递给链接器。

![wl](http://omp8s6jms.bkt.clouddn.com/image/git/wl.png)

下面通过一个非常简单的实例来进行验证:

	/**
	 * simpleWrap.c 
	 */
	#include <stdio.h>
	
	void *__real_malloc(size_t);
	void __real_free(void *);

	void *__wrap_malloc(size_t size)
	{
		printf("in wrap malloc\n");

		return  __real_malloc(size);
	}


	void __wrap_free(void *ptr)
	{
		printf("in wrap free\n");		

		__real_free(ptr);
	}




---








































