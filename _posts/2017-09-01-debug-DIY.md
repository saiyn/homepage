---
layout: post
title:  "调试技术之自制内存调试工具"
date:   2017-09-01 15:15:54
categories: debug
excerpt: debug linux wrap
---

* content
{:toc}

多年的实际工作经历表明，相比于设计和实现代码，调试代码的时间占工作时间的大部分。尤其是运气不好时，需要替别人擦屁股时，更是需要消耗大量时间去调试bug解决问题。

《The Art of Unix Programming》中有这么一段话，c和c++的中心问题在于它们要求程序员自己完成内存管理－－声明变量、显式管理链表、设置缓冲大小、检测或者防止缓冲区溢出，以及分配和回收动态存储。c的内存管理是复杂性和错误的渊源。对于处理复杂数据结构的程序而已，有研究估计**30%~40%的开发时间都用于存储管理**。这个估计甚至还没有包含对调试成本的影响。

所以现在工作中经常出现的情况时，一个bug花了几天甚至一周的时间进行定位，最终通过修改几行甚至是一行代码解决了问题。基于这些事实，提高自己的调试技术水平对于工作效率是至关重要的。**工欲善其事必先利其器**，掌握各种调试工具是立足之本，而自制调试工具往往比使用开源工具简单快速，最主要是部署方便。

本章主要介绍基于wrap通用函数库glibc中的malloc/free等动态内存管理的机制，实现一些工作中常用的定位内存问题的工具。

## malloc/free wrap的实现

ld链接器选项的`--wrap,symbol`的作用描述如下：

> Use a wrapper function for symbol. Any undefined reference to symbol will be resolved to "__wrap_symbol".
> Any undefined reference to "__real_symbol" will be resolved to symbol.

上面的意思就是，在ld进行链接时，对于`UND`状态的symbol符号的引用将解析成为对"__wrap_symbol"符合的引用。同时，对于`UND`状态的"__real_symbol"符号将被解析为symbol。于是，当我们自己实现`__wrap_malloc`和`__wrap_free`函数后，通过添加编译参数`-Wl,--wrap,malloc -Wl,--wrap,free`,就可以实现代码中所有调用malloc/free的地方最终实际上调用的是我们实现的`__wrap_malloc/__wrap_free`函数。同时我们在完成自己想要完成的工作后，通过调用"__real_malloc/__real_free"函数，去调用libc库中真正的"malloc/free"实现。通过这么一来一去，我们可以搞很多有意思的事情。


上面的编译选项`-Wl,<option>`其实是gcc的编译选项，它的作用是将`<option>`传递给链接器。

![wl](http://omp8s6jms.bkt.clouddn.com/image/git/wl.png)

下面通过一个非常简单的实例来进行验证:

	/**
	 * simpleWrap.c 
	 */
	#include <stdio.h>
	
	void *__real_malloc(size_t);
	void __real_free(void *);

	void *__wrap_malloc(size_t size)
	{
		printf("in wrap malloc\n");

		return  __real_malloc(size);
	}


	void __wrap_free(void *ptr)
	{
		printf("in wrap free\n");		

		__real_free(ptr);
	}
	
	/**
	 * simpleWrap_test.c
	 */
	 #include <stdio.h>
	 
	 int main(int argc, char *argv[])
	 {
	 	char *p = malloc(0);
		
		free(p);
		
		return 0;
	 }

执行`ar cru warp.a simpleWrap.c`进行编译生成静态库wrap.a.

执行`gcc simpleWrap_test.c wrap.a -Wl,--wrap,malloc -Wl,--wrap,free`进行编译链接，然后执行`./a.out`，得到如下输出:

![aout](http://omp8s6jms.bkt.clouddn.com/image/git/out_of_wr.png)

上面的例子中共涉及两个文件，为了后面描述的清楚明白，这里我们称`simpleWrap_test.c`为目标文件，编译生成的`a.out`为目标代码，`simpleWrap.c`为我们
的调试文件，`wrap.a`为调试静态库。

在实现能够在实际复杂的生产环境下的调试工具之前，我们来思考一个问题， 如果上面的例子需要依赖其他的一些动态链接库，而且这些动态链接库里面也存在malloc/free的调用，我们如何将这些动态库里面的malloc/free也wrap到我们的调试库呢？现在我们修改一下什么的目标文件，同时添加另一个.c文件，这个.c文件最终会生成.so文件参与新目标文件的生成。

	/**
	 * b.c
	 */
	
	#include <stdio.h>
	
	void foo(void)
	{
		char *q = malloc(0);
		printf("in foo\n");
	}

	/**
	 * simpleWrap_test.c
	 */
	 #include <stdio.h>
	 
	 extern void foo(void);
	 
	 int main(int argc, char *argv[])
	 {
	 	char *p = malloc(0);
		
		free(p);
		
		foo();
		
		return 0;
	 }
	 
执行`gcc -fPIC -shared -o b.so b.c`生成动态链接库文件b.so.

执行`gcc simpleWrap_test.c b.so wrap.a -Wl,--wrap,malloc -Wl,--wrap,free`生成新的目标文件a.out。运行结果如下:



## 基于malloc/free的wrap实现内存堆越界死机工具



## 基于malloc/free的wrap实现内存泄露检测工具

通过简单的几个步骤就可以包装了malloc和free这两个内存使用的主要函数，而真是利用上面的实现我们可以做很多关于内存检测调试方面的工作。下面主要介绍的是通过红黑树记录程序中内存申请和释放的情况来检测代码存在内存泄露的地方。基本的思路如下：

* 


---








































