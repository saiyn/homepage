---
layout: post
title:  "调试技术之自制内存调试工具"
date:   2017-09-01 15:15:54
categories: debug
excerpt: debug linux wrap
---

* content
{:toc}

多年的实际工作经历表明，相比于设计和实现代码，调试代码的时间占工作时间的大部分。尤其是运气不好时，需要替别人擦屁股时，更是需要消耗大量时间去调试bug解决问题。

《The Art of Unix Programming》中有这么一段话，c和c++的中心问题在于它们要求程序员自己完成内存管理－－声明变量、显式管理链表、设置缓冲大小、检测或者防止缓冲区溢出，以及分配和回收动态存储。c的内存管理是复杂性和错误的渊源。对于处理复杂数据结构的程序而已，有研究估计**30%~40%的开发时间都用于存储管理**。这个估计甚至还没有包含对调试成本的影响。

所以现在工作中经常出现的情况时，一个bug花了几天甚至一周的时间进行定位，最终通过修改几行甚至是一行代码解决了问题。基于这些事实，提高自己的调试技术水平对于工作效率是至关重要的。**工欲善其事必先利其器**，掌握各种调试工具是立足之本，而自制调试工具往往比使用开源工具简单快速，最主要是部署方便。

本章主要介绍基于wrap通用函数库glibc中的malloc/free等动态内存管理的机制，实现一些工作中常用的定位内存问题的工具。一开始，我也是满怀希望于valgrind能够帮助解决问题的，但是几次好不容易将valgrind部署好了，却发现valgrind起不到任何作用，一方面是valgrind给出的内存问题并没有覆盖到实际问题点，另外一方面是valgrind运行太过缓慢，工程启动超过40分钟不说，好不容易启动起来了，发现web登录超时无法使用，简直奔溃。

所以还是自己动手方能丰衣足食。

## malloc/free wrap的实现之基于静态库

ld链接器选项的`--wrap,symbol`的作用描述如下：

> Use a wrapper function for symbol. Any undefined reference to symbol will be resolved to "__wrap_symbol".
> Any undefined reference to "__real_symbol" will be resolved to symbol.

上面的意思就是，在ld进行链接时，对于`UND`状态的symbol符号的引用将解析成为对"__wrap_symbol"符合的引用。同时，对于`UND`状态的"__real_symbol"符号将被解析为symbol。于是，当我们自己实现`__wrap_malloc`和`__wrap_free`函数后，通过添加编译参数`-Wl,--wrap,malloc -Wl,--wrap,free`,就可以实现代码中所有调用malloc/free的地方最终实际上调用的是我们实现的`__wrap_malloc/__wrap_free`函数。同时我们在完成自己想要完成的工作后，通过调用"__real_malloc/__real_free"函数，去调用libc库中真正的"malloc/free"实现。通过这么一来一去，我们可以搞很多有意思的事情。


上面的编译选项`-Wl,<option>`其实是gcc的编译选项，它的作用是将`<option>`传递给链接器。

![wl](http://omp8s6jms.bkt.clouddn.com/image/git/wl.png)

下面通过一个非常简单的实例来进行验证:

	/**
	 * simpleWrap.c 
	 */
	#include <stdio.h>
	
	void *__real_malloc(size_t);
	void __real_free(void *);

	void *__wrap_malloc(size_t size)
	{
		printf("in wrap malloc\n");

		return  __real_malloc(size);
	}


	void __wrap_free(void *ptr)
	{
		printf("in wrap free\n");		

		__real_free(ptr);
	}
	
	/**
	 * simpleWrap_test.c
	 */
	 #include <stdio.h>
	 #include <stdlib.h>
	 
	 int main(int argc, char *argv[])
	 {
	 	char *p = malloc(0);
		
		free(p);
		
		return 0;
	 }

执行`gcc -c simpleWrap.c; ar cru warp.a simpleWrap.o`进行编译生成静态库wrap.a.

执行`gcc simpleWrap_test.c wrap.a -Wl,--wrap,malloc -Wl,--wrap,free`进行编译链接，然后执行`./a.out`，得到如下输出:

![aout](http://omp8s6jms.bkt.clouddn.com/image/git/out_of_wr.png)

上面的例子中共涉及两个文件，为了后面描述的清楚明白，这里我们称`simpleWrap_test.c`为目标文件，编译生成的`a.out`为目标代码，`simpleWrap.c`为我们
的调试文件，`wrap.a`为调试静态库。

在实现能够在实际复杂的生产环境下的调试工具之前，我们来思考一个问题， 如果上面的例子需要依赖其他的一些动态链接库，而且这些动态链接库里面也存在malloc/free的调用，我们如何将这些动态库里面的malloc/free也wrap到我们的调试库呢？现在我们修改一下什么的目标文件，同时添加另一个.c文件，这个.c文件最终会生成.so文件参与新目标文件的生成。

	/**
	 * b.c
	 */
	
	#include <stdio.h>
	#inlcude <stdlib.h>
	
	void foo(void)
	{
		char *q = malloc(0);
		printf("in foo\n");
	}

	/**
	 * simpleWrap_test.c
	 */
	 #include <stdio.h>
	 #include <stdlib.h>
	 
	 extern void foo(void);
	 
	 int main(int argc, char *argv[])
	 {
	 	char *p = malloc(0);
		
		free(p);
		
		foo();
		
		return 0;
	 }
	 
执行`gcc -fPIC -shared -o b.so b.c`生成动态链接库文件b.so,执行`readelf -s b.so`查看一下符号表:

![bso_sybtab](http://omp8s6jms.bkt.clouddn.com/image/git/f10_24_0.png)

从上面的"UND malloc@@GLIBC_2.2.5"这一行可见，动态库b.so中的malloc在b.c文件进行编译时已经被指定最终会在链接时链接到glibc库中的malloc实现。

执行`gcc simpleWrap_test.c b.so wrap.a -Wl,--wrap,malloc -Wl,--wrap,free`生成新的目标文件a.out。运行结果如下:

![aout_sytab](http://omp8s6jms.bkt.clouddn.com/image/git/f10_24_1.png)

从结果也和我们的预期一样，b.so中的foo()函数中的malloc在执行时并没有打印"in malloc"语句，说明，通过上面的方法是无法做到wrap已经编译好了的动态库中的函数的。

所以，下面我们的目标是实现一个可以wrap掉工程中所有依赖的动态库中的malloc/free的调试库。当然，你可能已经猜到了，这个新的调试库应该也是一个动态库才行。

## malloc/free wrap的实现之基于动态库

相对于静态库的实现机制来说，动态库的实现比较复杂，对于理解动态链接的过程涉及的知识原理有一定要求。所以在说明具体实现之前，先了解一下需要使用到的动态链接知识。

这方面的知识在 [c开发笔记](http://saiyn.github.io/homepage/2016/08/07/C/) 里已经有一些介绍，下面补充其中没有说明的。

如果说上面的静态库实现方式是显示地借助于链接器ld的链接选项`--wrap`，那么动态库的实现可没有这样的选项协助，而是要借助于共享对象的**全局符号介入(Global System Interpose)**处理机制。

什么是全局符号介入，下面通过一个实例来说明。

	/**
	 * a1.c
	 */
	 #include <stdio.h>
	 
	 void a(void)
	 {
	 	printf("a1.c\n");
	 }
	 
	 /**
	 * a2.c
	 */
	 #include <stdio.h>
	 
	 void a(void)
	 {
	 	printf("a2.c\n");
	 }
	 
	 /**
	 * main.c
	 */
	 #include <stdio.h>
	 
	 extern void a(void);
	 
	 int main()
	 {
	 	a();
		
		for(;;);
		
		return 0;
	 }	
	

先执行:

`gcc -fPIC -shared -o a1.so a1.c`

`gcc -fPIC -shared -o a2.so a2.c`

分别生成a1.so和a2.so

然后执行:

`gcc -o a1a2 main.c a1.so a2.so`

`gcc -o a2a1 main.c a2.so a1.so`

分别执行a1a2和a2a1发现，前者输出a1.c而后者输出a2.c，这说明目标文件在最终执行链接时只链接了a1和a2中的一个，而且是谁在依赖关系前面就链接哪一个。

执行`readelf -d a1a2(a2a1)`查看目标文件中的`.dynamic`段如下:

![dynamic_sec](http://omp8s6jms.bkt.clouddn.com/image/git/f10_24_2.png)

可以看到，a1.so和a2.so都被包含进来了，更进一步的我们执行`./a1a2 &`,然后通过`cat /proc/xxx/maps`来看一下进程地址空间中的内容:

![proc_maps](http://omp8s6jms.bkt.clouddn.com/image/git/f10_24_3.png)

可以看到，a1.so和a2.so都被加载进内存了，但是a1.so和a2.so中相同的函数并没有起冲突。那么唯一的解释就是其中的一个函数被忽略了。这种一个共享对象里面的
全局符号被另一个共享对象全局符号覆盖的现象就被称为:**全局符号介入**.

在Linux下，动态链接器是这样处理全局符号介入问题的，那就是**当一个符号需要被加入全局符号表时，如果相同的符号名已经存在，则后加的符号被忽略**。从动态链接器的装载顺序来看，它是按照广度优先的顺序进行装载的。

在了解了上面的知识点后，下面开始代码的实现。

	/**
	 * simpleWrap.c
	 */
	 
	 #define _GNU_SOURCE
	 #include <stdlib.h>
	 #include <stdio.h>
	 #include <dlfcn.h>
	 #include <assert.h>
	 
	 typedef void *(*malloc_func)(size_t);
	 typedef void (*free_func)(void *);
	 
	 malloc_func real_malloc = NULL;
	 free_func   real_free = NULL;
	 
	 static char firstBuffer[1024];
	 
	 void wrap_init(void)
	 {
	 	static int once = 1;
		
		if(!once)
		{
			return;
		}
		
		once = 0;
		
		real_malloc = (malloc_func)dlsym(RTLD_NEXT, "malloc");
		assert(real_malloc);
		
		real_free = (free_func)dlsym(RTLD_NEXT, "free");
		assert(real_free);
		
		printf("wrap init done\n");
	  }
	
	  void *malloc(size_t size)
	  {
	 	wrap_init();
		
		printf("in wrap malloc\n");
		
		return real_malloc(size);
	  }
	
	  void free(void *ptr)
	  {
	 	wrap_init();
	 	
	 	printf("in wrap free\n");
		
		real_free(ptr);
	  }
	 
	 
	  /**
	   * simpleWrap_test.c
	   */
	  #include <stdio.h>
	  #include <stdlib.h>
	 
	  int main(int argc, char *argv[])
	  {
	 	char *p = malloc(0);
		
		free(p);
		
		return 0;
	  }
	 
	 
	 
	 
	
---
## 基于malloc/free的wrap实现内存堆越界死机工具


---
## 基于malloc/free的wrap实现内存泄露检测工具

通过简单的几个步骤就可以包装了malloc和free这两个内存使用的主要函数，而真是利用上面的实现我们可以做很多关于内存检测调试方面的工作。下面主要介绍的是通过红黑树记录程序中内存申请和释放的情况来检测代码存在内存泄露的地方。基本的思路如下：

* 


---








































