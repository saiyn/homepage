---
layout: post
title:  "调试技术之自制内存调试工具"
date:   2017-09-01 15:15:54
categories: debug
excerpt: debug linux wrap
---

* content
{:toc}

多年的实际工作经历表明，相比于设计和实现代码，调试代码的时间占工作时间的大部分。尤其是运气不好时，需要替别人擦屁股时，更是需要消耗大量时间去调试bug解决问题。

《The Art of Unix Programming》中有这么一段话，c和c++的中心问题在于它们要求程序员自己完成内存管理－－声明变量、显式管理链表、设置缓冲大小、检测或者防止缓冲区溢出，以及分配和回收动态存储。c的内存管理是复杂性和错误的渊源。对于处理复杂数据结构的程序而已，有研究估计**30%~40%的开发时间都用于存储管理**。这个估计甚至还没有包含对调试成本的影响。

所以现在工作中经常出现的情况时，一个bug花了几天甚至一周的时间进行定位，最终通过修改几行甚至是一行代码解决了问题。基于这些事实，提高自己的调试技术水平对于工作效率是至关重要的。**工欲善其事必先利其器**，掌握各种调试工具是立足之本，而自制调试工具往往比使用开源工具简单快速，最主要是部署方便。

本章主要介绍基于wrap通用函数库glibc中的malloc/free等动态内存管理的机制，实现一些工作中常用的定位内存问题的工具。

## malloc/free wrap的实现

ld链接器选项的`--wrap,func`用于实现在静态链接时，func符号的链接地址由func函数变成`__wrap_func`函数地址。同时，未定义的``__real_func`函数将被解析为func。于是，当我们自己实现`__wrap_malloc`和`__wrap_free`函数后，通过添加编译参数`-Wl,--wrap,malloc -Wl,--wrap,free`,就可以实现代码中所有调用malloc/free的地方最终实际上调用的是我们实现的`__wrap_malloc/__wrap_free`函数。


上面的编译选项`-Wl,<option>`其实是gcc的编译选项，它的作用是将`<option>`传递给链接器。

![wl](http://omp8s6jms.bkt.clouddn.com/image/git/wl.png)

下面通过一个非常简单的实例来进行验证:

	/**
	 * simpleWrap.c 
	 */
	#include <stdio.h>
	
	void *__real_malloc(size_t);
	void __real_free(void *);

	void *__wrap_malloc(size_t size)
	{
		printf("in wrap malloc\n");

		return  __real_malloc(size);
	}


	void __wrap_free(void *ptr)
	{
		printf("in wrap free\n");		

		__real_free(ptr);
	}

执行`gcc simpleWrap_test.c wrap.a -Wl,--wrap,malloc --wrap,free`进行编译链接，然后执行`./a.out`，得到如下输出:

![aout](http://omp8s6jms.bkt.clouddn.com/image/git/out_of_wr.png)


## 基于malloc/free的wrap实现内存泄露检测工具

通过简单的几个步骤就可以包装了malloc和free这两个内存使用的主要函数，而真是利用上面的实现我们可以做很多关于内存检测调试方面的工作。下面主要介绍的是通过红黑树记录程序中内存申请和释放的情况来检测代码存在内存泄露的地方。基本的思路如下：

* 


---








































