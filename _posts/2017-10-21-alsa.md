---
layout: post
title:  "ALSA开发笔记"
date:   2017-10-21 15:15:54
categories: Linux-Kernel
excerpt: alsa linux alsa-lib alsa-driver hda
---

* content
{:toc}

初次接触ALSA感觉其深不可测，涉及到内核驱动代码的分析，架构的理解、应用层的alsa-lib库的使用以及系统运行环境的相关配置管理机制。一开始因为缺乏总体上的认识，
所以只能以项目中的遇到的实际问题为起点，一点一点深入其中。经过差不多两年的积累，现在无论时总体上的理解还是细节上的把握得有了一些收获。

网上关于这块的文章，大部分会先从概念开始介绍alsa，本文通过定位解决实际问题来深入剖析alsa实现细节。

---

<br />

# ALSA驱动

<br />

## 定位ALSA内核输出DMA卡死问题

<br />

### 定位ALSA内核层问题的手段

<br />

想要有效率的定位解决内核模块的问题，一定要较全面地掌握内核通过的调试技术支持以及相应模块通过的调试机制。如果只是依靠简单的添加printk来定位问题，效率和效果都很差。

<br />

#### 借助trace-cmd工具使用ALSA中预留的Tracepoints

<br />

> ALSA PCM core register snd_pcm subsystem to kernel tracepoint system. This subsystem includes two categories of tracepoints;
> for state of PCM buffer and for processing of PCM hardware parameters.

<br />

alsa驱动中有两种Tracepoint, 一个是用于追踪pcm buffer状态的，一个是pcm的硬件参数配置。前者主要涉及hwptr(读指针，内核层更新)、applptr(写指针，应用层更新)、xrun和hw_ptr_error；后者为hw_mask_param和hw_interval_param。使用trace-cmd工具测试发现，4.4.7版本的内核只支持前者中的hwptr、xrun和hw_ptr_error。


<br />

#### 分析proc信息


<br />

#### 使用perf工具

<br />

---

### 驱动细节研究

<br />

解决问题的前提是对相关驱动的细节有足够的掌握，下面从不同层面、不同角度剖析ALSA驱动的实现细节。而理解驱动代码的前提是对相应的硬件架构有一定了解，
软件完成硬件的抽象，直接理解抽象的东西难度太大，所以需要先理解硬件。

<br />

#### 硬件基础

<br />

先通过硬件框图来从整体上认识一下HDA内核架构以及HDA在整个系统中的位置。

![hda_5](http://omp8s6jms.bkt.clouddn.com/image/git/hda_5.png)

<br />

* Controler: HDA控制器是一个控制I/O外设的总线，它主要通过PCI总线挂接到CPU上。HDA内部包含多个DMA引擎，每一个引擎用来传输a single audio "stream"。

* Link: Link这个抽象可以类比为I2S的功能。The controller is physically connected to one or more codecs via the HDA link.

* Codec: 一个或者多个codecs挂接在Link上。每个codec通过时分复用方式从link上提取属于自己的streams.

<br />

下面来介绍一下上面提到的stream概念。

**Streams and Channels**

HDA中通过抽象出streams和channels来描述link中传输的数据的方式。A *stream* is a logical or virtual connection created between a
system memory buffer and the codec rendering that data, which is driven by a single DMA channel through the link.channels就是
我们很熟悉的声道的概念，所以，一个立体音stream中包含L和R两个channel。

<br />

![hda_6](http://omp8s6jms.bkt.clouddn.com/image/git/hda_6.png)

上图描述了上面提到的各个概念之间的关系。每个active stream必须连接到一个DMA引擎上，上面的stream 1,2,3都是active stream,其中1,3是output类型的
stream,2是input类型的stream.4就是一个inactive stream.

上面提到HDA中的Link概念和I2S总线很类似，当然有很大不同，下图描述了link、stream、channels之间的关系。


![hda_7](http://omp8s6jms.bkt.clouddn.com/image/git/hda_7.png)

<br />

Link上传输的是一个个frames,而且每个frams的大小是固定的，等于48k采样率20.83us的数据量。因为每个frams occur at a fixed rate,所以
如果传输的音频采样率不是48k，那么there will be more or less than one sample block in each frame for that stream.

另外，和I2S总线最大不同的是，HDA的each frame contains command or control information and then as many stream sample blocks(labeled S-1,
S-2.S-3)as are needed.




HDA详细的硬件细节参见[这篇资料](https://www.intel.com/content/dam/www/public/us/en/documents/product-specifications/high-definition-audio-specification.pdf)


<br />

#### HDA 驱动已知问题

<br />

> HD-audio is the new standard on-board audio component on modern PCs after AC97. Although Linux has been supprting HD-audio since
> long time ago, there are often problems with new machines. A part of the problem is broken BIOS, and the rest is the driver implementation.

<br />

笔者参与的项目中的音频驱动一直都是基于intel的HDA接口，定位解决驱动中的问题，熟悉HD-Audio Driver是必不可少的。而且从上面描述来看，这个驱动中还是有不少坑的。

<br />

##### HD-Audio Controller

<br />

**DMA-Position Problem**

> The most common problem of the controller is the inaccurate **DMA pointer** reporting. The DMA pointer for playback and capture can
> be read in two ways, either via a **LPIB register** or via a **position-buffer map**. 

默认情况下，驱动会从io-mapped position-buffer中读取缓存指针信息，如果position-buffer死掉了就去读取LPIB寄存器。这部分的代码如下:

![hda_1](http://omp8s6jms.bkt.clouddn.com/image/git/hda_1.png)

<br />

我们可以通过模块参数module_param中的position_fix变量来修改上面的行为。

> * position_fix=1 means to use LPIB method explicitly.
> * position_fix=2 means to use the position-buffer.
> * position_fix=3 means to use a combination of both methods, needed for some VIA controllers.
> * position_fix=4 is another combination available for all controllers, and uses LPIB for playback,and position-buffer for capture.
> * 0 is the default value for all other controllers,就是一开始描述的行为。

position_fix变量作用的代码如下，函数在初始化阶段azx_create()中调用。

![hda_2](http://omp8s6jms.bkt.clouddn.com/image/git/hda_2.png)

<br />

另外还有一个坑是HDA中的中断唤醒时间：

> Every controller is known to be broken regarding the wake-up timing. It wakes up a few samples  before actually processing the 
> data on the buffer, which caused a lot of problem. Since 2.6.27 kernel, the driver puts **an artifical delay** to the wake up 
> timing. This delay is controlled via **bdl_pos_adj** option.

bdl_pos_adj也是一个模块参数，默认是负值，不同的控制器会在初始化时将它设为不同值。内核代码中初始化部分的代码如下:

![hda_3](http://omp8s6jms.bkt.clouddn.com/image/git/hda_3.png)

<br />

如果bdl_pos_adj的值设置的不合适，内核会打印提示"IRQ timing workaround is actived for card x. Suggest a bigger bdl_pos_adj"。那么这个
bdl_pos_adj具体在哪里发挥重要调节作用呢？答案如下，下面函数定义在sound/hda/hdac_stream.c文件中:

![hda_4](http://omp8s6jms.bkt.clouddn.com/image/git/hda_4.png)

<br />

**Codec-probing Problem**


<br />

----
#### HDA驱动代码细节

<br />

HD-Audio硬件上主要由两部分组成，the controller chip 和 the codec chips on the HD-Audio bus.Linux内核驱动只提供一个snd-hda-intel驱动
来支持所有HDA控制器。另外，对于不同的codec解码器，the snd-hda-intel has a generic parser as a fallback, 但是通常不同的codec会使用
各自的解码器(coded in patch_*.c)。比如，笔者使用的alc662的codec对应的解码器就是由patch_realtek.c提供的。


****




> In design of ALSA PCM core, status and control data for runtime of ALSA PCM substream are shared between kernel/usr spaces by page 
> frame mapping with read-only attribute. Both of hardware-side and application-side position on PCM buffer are maintained as a part of 
> the status data. In a view of ALSA PCM application, these two positions can be updated by executing ioctl(2) with some commands.



