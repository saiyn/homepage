---
layout: post
title:  "ALSA开发笔记"
date:   2017-10-21 15:15:54
categories: linux
excerpt: alsa linux alsa-lib alsa-driver hda
---

* content
{:toc}

初次接触ALSA感觉其深不可测，涉及到内核驱动代码的分析，架构的理解、应用层的alsa-lib库的使用以及系统运行环境的相关配置管理机制。一开始因为缺乏总体上的认识，
所以只能以项目中的遇到的实际问题为起点，一点一点深入其中。经过差不多两年的积累，现在无论时总体上的理解还是细节上的把握得有了一些收获。

网上关于这块的文章，大部分会先从概念开始介绍alsa，本文通过定位解决实际问题来深入剖析alsa实现细节。

---

<br />

# ALSA驱动

<br />

## 定位ALSA内核输出DMA卡死问题

<br />

### 定位ALSA内核层问题的手段

<br />

想要有效率的定位解决内核模块的问题，一定要较全面地掌握内核通过的调试技术支持以及相应模块通过的调试机制。如果只是依靠简单的添加printk来定位问题，效率和效果都很差。

<br />

#### 借助trace-cmd工具使用ALSA中预留的Tracepoints

<br />

> ALSA PCM core register snd_pcm subsystem to kernel tracepoint system. This subsystem includes two categories of tracepoints;
> for state of PCM buffer and for processing of PCM hardware parameters.

<br />

alsa驱动中有两种Tracepoint, 一个是用于追踪pcm buffer状态的，一个是pcm的硬件参数配置。前者主要涉及hwptr(读指针，内核层更新)、applptr(写指针，应用层更新)、xrun和hw_ptr_error；后者为hw_mask_param和hw_interval_param。使用trace-cmd工具测试发现，4.4.7版本的内核只支持前者中的hwptr、xrun和hw_ptr_error。


<br />

#### 分析proc信息

<br />

### 使用perf工具

<br />

### HD-Audio Driver

<br />

> HD-audio is the new standard on-board audio component on modern PCs after AC97. Although Linux has been supprting HD-audio since
> long time ago, there are often problems with new machines. A part of the problem is broken BIOS, and the rest is the driver implementation.

<br />

笔者参与的项目中的音频驱动一直都是基于intel的HDA接口，定位解决驱动中的问题，熟悉HD-Audio Driver是必不可少的。而且从上面描述来看，这个驱动中还是有不少坑的。

<br />

#### HD-Audio Controller

<br />

**DMA-Position Problem**

> The most common problem of the controller is the inaccurate **DMA pointer** reporting. The DMA pointer for playback and capture can
> be read in two ways, either via a **LPIB register** or via a **position-buffer map**. 

默认情况下，驱动会从io-mapped position-buffer中读取缓存指针信息，如果position-buffer死掉了就去读取LPIB寄存器。这部分的代码如下:

![hda_1](http://omp8s6jms.bkt.clouddn.com/image/git/hda_1.png)

<br />

我们可以通过模块参数module_param中的position_fix变量来修改上面的行为。

> * position_fix=1 means to use LPIB method explicitly.
> * position_fix=2 means to use the position-buffer.
> * position_fix=3 means to use a combination of both methods, needed for some VIA controllers.
> * position_fix=4 is another combination available for all controllers, and uses LPIB for playback,and position-buffer for capture.
> * 0 is the default value for all other controllers,就是一开始描述的行为。

position_fix变量作用的代码如下，函数在初始化阶段azx_create()中调用。

![hda_2](http://omp8s6jms.bkt.clouddn.com/image/git/hda_2.png)

<br />

另外还有一个坑是HDA中的中断唤醒时间：

> Every controller is known to be broken regarding the wake-up timing. It wakes up a few samples  before actually processing the 
> data on the buffer, which caused a lot of problem. Since 2.6.27 kernel, the driver puts **an artifical delay** to the wake up 
> timing. This delay is controlled via **bdl_pos_adj** option.

bdl_pos_adj也是一个模块参数，默认是负值，不同的控制器会在初始化时将它设为不同值。内核代码中初始化部分的代码如下:

![hda_3](http://omp8s6jms.bkt.clouddn.com/image/git/hda_3.png)

<br />

如果bdl_pos_adj的值设置的不合适，内核会打印提示"IRQ timing workaround is actived for card x. Suggest a bigger bdl_pos_adj"。那么这个
bdl_pos_adj具体在哪里发挥重要调节作用呢？答案如下，下面函数定义在sound/hda/hdac_stream.c文件中:

![hda_4](http://omp8s6jms.bkt.clouddn.com/image/git/hda_4.png)

<br />

**Codec-probing Problem**




> In design of ALSA PCM core, status and control data for runtime of ALSA PCM substream are shared between kernel/usr spaces by page 
> frame mapping with read-only attribute. Both of hardware-side and application-side position on PCM buffer are maintained as a part of 
> the status data. In a view of ALSA PCM application, these two positions can be updated by executing ioctl(2) with some commands.



