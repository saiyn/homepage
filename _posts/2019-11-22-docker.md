---
layout: post
title:  "Docker 笔记"
date:   2019-11-21 15:15:54
categories: Tools
excerpt: Docker linux container
---

* content
{:toc}


> 更新于2022-12-17

---


# 使用Docker构建Nmap本地扫描容器

---

使用nmap扫描local LAN网络时，假设我们希望nmap中的arp功能也能正常work，就需要nmap运行的网络和目标网络处于同一个网段内。但是由于容器化nmap进程后，容器网络本身是隔离的，所以默认情况下容器内的nmap运行网络和目标网络不会处于同一个网段。这时就需要特殊的设置来修改。






<br />


# 使用Docker构建交叉编译环境

---

* Dockerfile

假设我们的toolchain文件为`RT6125VW_SET.tgz`，这里面包含有编译工具和`rootfs`。

```
    FROM ubuntu:18.04

    RUN dpkg --add-architecture i386 && \
        apt-get update && \
        apt-get install --fix-missing -y --no-install-recommends libz-dev libexpat-dev \
        bison flex bsdmainutils build-essential libc6:i386 libstdc++6:i386 m4 automake \
        pkg-config libtool && \
        rm -rf /var/lib/apt/lists/*

    ARG TOOLCHIAN_ROOT=/opt/toolchain
    ADD ./RT6125VW_SET.tgz ${TOOLCHIAN_ROOT}


    WORKDIR /build

    ENV ARCH=arm-linux
    ENV CROSS_COMPILE=aarch64-poky-linux-
    ENV TOOLCHAIN_PATH=${TOOLCHIAN_ROOT}/RT6125VW_SET/bsp/aarch64-venus/usr
    ENV PATH="${PATH}:${TOOLCHAIN_PATH}/bin/aarch64-poky-linux"


```

上面的Dockerfile中通过`dpkg --add-architecture i386`让build环境支持multiarch, 这样可以兼容32bit平台的交叉编译。具体关于multiarch的细节参见[这里](https://wiki.debian.org/Multiarch/Implementation).



* build image

假设Dockerfile和toolchain压缩文件都在当前目录下 , 执行`docker build -t poky-image .` 创建docker image

* pipeline

image准备好后就是启动容器去run build了，假设我们使用githun action的pipeline去做，

```
    jobs:
      poky:
        
        ...

        steps:
          - name build
            run: docker run -i -e PROGVER=1.0.${{github.run_number}} -v ${{github.WORKSPACE}}:/build  poky-image bash -c "make clean && make all"

          ...



```




<br />

# Basic

<br />

## 安装docker

<br />

[参考这个](https://docs.docker.com/engine/install/ubuntu/)


<br />

## 基本命令

<br />

* 进入container内的shell -> `sudo docker container exec -it 3695c98d9f78 /bin/bash`
* 清除系统中所有的container和images -> `sudo docker system prune -a`
* 清除系统中所有的docker volumes -> `sudo docker volume prune`
* 清除所有container的log -> `sudo sh -c "truncate -s 0 /var/lib/docker/containers/*/*-json.log"`

<br />


## DockerHub的使用

<br />

基于别人public的image进行开发后，可以commit然后push到自己的DokcerHub仓库下。

比如上传修改后的image到我的elk仓库：saiyn/elk

* 执行`docker container ps`查看elk的CONTAINER ID， 假设为c78ade920bae.
* 执行`docker commit -m "refine index pattern;add one more filebeat input" c78ade920bae saiyn/elk:v1.0.3`生成一个新的image，并且打上tag：v1.0.3
* 执行`docker push saiyn/elk:v1.0.3`将新image推送到dockerHub的elk仓库.


<br />



## docker-compose的应用

<br />

### 重新build并启动某一个service

<br />
在我们更新了ui容器的js代码后，如果只是执行`docker-compose restart ui`会发现网页并没有更新
这时可以依次执行如下命令:

* docker-compose stop ui
* docker-compose build --no-cache ui
* docker-compose up -d --no-deps ui

<br />

---

# docker in Pycharm

<br />

## pycharm in windows

<br />

> requirement: pycharm professional version + windows 10 enterprise

**key step to set docker-compose env for pycharm**

* install docker desktop
* exec `docker pull busybox` in docker desktop to install busybox image
* enable `Expose daemon on tcp://localhost:2375 without tls` in docker desktop setting page
* set Engine API URL to `tcp://localhost::2375` in pycharm FILE->Setting->Build,Execution,Deployment setting page
* Add python Interpreter in pycharm FILE->Setting->Project:xxx ->Docker Compose setting page

> 上面这一步是可以让我们直接在pycharm中调试docker container中的python工程，比如你的docker-compose是搭建一个web server项目，里面构建了7、8个container, 其他一个叫`api`
> 的contaienr可能就是你基于flask构建的web server,这时你在docker compose setting apge中的serice选项中选择api。




## pycharm in ubuntu

<br />

在window上设置Docker的`Expose daemon on tcp://localhost:2375 without TLS`很方便，当时ubuntu上有点免费，查询了各种解决方案，发现使用nmap的ncat工具可以轻松解决问题。

  $sudo ncat -lknvp 2375 -c "ncat -U /var/run/docker.sock"

<br />


# dockerfile for RockyLinux

centos 宣布EOS之后，前centos的创始人基于centos创立了RockyLinux发行版

```
  FROM rockylinux:8

  RUN yum -y groupinstall "Development Tools" && \
      yum -y install tar && \
      yum -y install perl && \
      yum -y install wget && \
      yum -y install expat-devel && \
      yum -y install zlib zlib-devel && \
      yum -y install bison openssl-devel && \
      wget ftp://ftp.gnu.org/gnu/autoconf/autoconf-2.69.tar.gz && \
      tar zxvf autoconf-2.69.tar.gz && \
      cd autoconf-2.69 && \
      ./configure --prefix=/usr/ && \
      make && make install && \
      cd .. && \
      rm -f autoconf-2.69.tar.gz
```


