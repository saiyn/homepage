---
layout: post
title:  "Docker 笔记"
date:   2019-11-21 15:15:54
categories: Tools
excerpt: Docker linux container
---

* content
{:toc}


> 更新于2023-02-24

---


# 使用Docker构建Nmap本地扫描容器

---

使用nmap扫描local LAN网络时，假设我们希望nmap中的arp功能也能正常work，就需要nmap运行的网络和目标网络处于同一个网段内。但是由于容器化nmap进程后，容器网络本身是隔离的，所以默认情况下容器内的nmap运行网络和目标网络不会处于同一个网段。这时就需要特殊的设置来修改。

## macvlan


## 实战环境

---

在一台服务器上通过docker部署web service、MQTT broker、以及nmap scan 3个容器，该服务器使能了2个物理网口，其中`enp125s0f2`网口配置了公网IP，方便ssh远程登录该服务器进行操作，另外一个网口`enp125s0f1`(192.168.3.2)连接到了路由器的LAN口，路由器的WLAN口并没有连接到公网。

* 需求： 容器中的nmap scan可以扫描`enp125s0f1`网口的局域网中的设备。

### 网络配置

---

* 创建一个macvlan驱动的网络

```
  docker network create -d macvlan -o parent=enp125s0f1 \
  --subnet 192.168.3.0/24 \
  --gateway 192.168.3.1 \
  --ip-range 192.168.3.192/27 \
  --aux-address 'host=192.168.3.223' \
  nmap-scan

```

上面的`ip-range和aux-address`设置至关重要，其中`ip-range`的设置关系到后面的路由设置，而`aux-address`是为了防止docker将同样的ip地址分配给了某个container而造成最后的ip地址冲突。
创建成功后执行`docker network inspect nmap-scan`可以查看所创建网络的具体信息。


![docker_0.png](https://raw.githubusercontent.com/saiyn/homepage/gh-pages/images/docker_0.png)

上面的`Containers`表示的是当前挂在此网络下的容器实例。


初始的设想是，nmap scan的容器是挂在nmap-scan这个macvlan网络下的，这个虚拟设备和服务器的`enp125s0f1`网口在同一个局域网网段内，所以应该可以访问服务器上的service的，只要这个service启动时bind的是IPANY，即`0.0.0.0`。但是docker网络是有意隔离host和container网络的，即nmap scan容器是无法ping通host的。解决办法就是在host上新建一个虚拟网卡，并且该网卡也是挂在nmap-scan这个macvlan驱动的网络里。


* 创建macvlan驱动的虚拟网卡

```
  ip link add saiyn-shim link enp125s0f1 type macvlan  mode bridge

```

* 设置ip并使能网卡

```
  ip addr add 192.168.3.223/32 dev saiyn-shim 
  ip link set saiyn-shim up

```

注意上面的`192.168.3.223`就是通过`aux-address`选项保留下来的ip。

![docker_1.png](https://raw.githubusercontent.com/saiyn/homepage/gh-pages/images/docker_1.png)


* 设置路由

```
  ip route add 192.168.3.192/27 dev nmap-shim

```

这里的路由设置非常重要，前面通过`--ip-range`的选项将基于`enp125s0f1`网卡而创建的子虚拟网卡`saiyn-shim`隔离到一个子网中，然后这里就很自然的可以设置相关的路由了。

* 启动nmap scan容器

```
  docker run -itd --network=nmap-scan -e SERVICE_IP=$service -v `pwd`/data:/opt/thingsScan/data thingsscan/thingsscan:normal_arm64

```

也可以直接指定容器的ip地址

```
  docker run -itd --network=namp-scan-new -e SERVICE_IP=$service --ip=$ip -v `pwd`/data:/opt/thingsScan/data thingsscan/thingsscan:normal_arm64

```

![docker_2.png](https://raw.githubusercontent.com/saiyn/homepage/gh-pages/images/docker_2.png)


* 验证网络

在host ping 容器ip

![docker_3.png](https://raw.githubusercontent.com/saiyn/homepage/gh-pages/images/docker_3.png)


<br />


# 使用Docker构建交叉编译环境

---

* Dockerfile

假设我们的toolchain文件为`RT6125VW_SET.tgz`，这里面包含有编译工具和`rootfs`。

```
    FROM ubuntu:18.04

    RUN dpkg --add-architecture i386 && \
        apt-get update && \
        apt-get install --fix-missing -y --no-install-recommends libz-dev libexpat-dev \
        bison flex bsdmainutils build-essential libc6:i386 libstdc++6:i386 m4 automake \
        pkg-config libtool && \
        rm -rf /var/lib/apt/lists/*

    ARG TOOLCHIAN_ROOT=/opt/toolchain
    ADD ./RT6125VW_SET.tgz ${TOOLCHIAN_ROOT}


    WORKDIR /build

    ENV ARCH=arm-linux
    ENV CROSS_COMPILE=aarch64-poky-linux-
    ENV TOOLCHAIN_PATH=${TOOLCHIAN_ROOT}/RT6125VW_SET/bsp/aarch64-venus/usr
    ENV PATH="${PATH}:${TOOLCHAIN_PATH}/bin/aarch64-poky-linux"


```

上面的Dockerfile中通过`dpkg --add-architecture i386`让build环境支持multiarch, 这样可以兼容32bit平台的交叉编译。具体关于multiarch的细节参见[这里](https://wiki.debian.org/Multiarch/Implementation).



* build image

假设Dockerfile和toolchain压缩文件都在当前目录下 , 执行`docker build -t poky-image .` 创建docker image

* pipeline

image准备好后就是启动容器去run build了，假设我们使用githun action的pipeline去做，

```
    jobs:
      poky:
        
        ...

        steps:
          - name build
            run: docker run -i -e PROGVER=1.0.${{github.run_number}} -v ${{github.WORKSPACE}}:/build  poky-image bash -c "make clean && make all"

          ...



```




<br />

# Basic

<br />

## 安装docker

<br />

[参考这个](https://docs.docker.com/engine/install/ubuntu/)


<br />

## 基本命令

<br />

* 进入container内的shell -> `sudo docker container exec -it 3695c98d9f78 /bin/bash`
* 清除系统中所有的container和images -> `sudo docker system prune -a`
* 清除系统中所有的docker volumes -> `sudo docker volume prune`
* 清除所有container的log -> `sudo sh -c "truncate -s 0 /var/lib/docker/containers/*/*-json.log"`

<br />


## DockerHub的使用

<br />

基于别人public的image进行开发后，可以commit然后push到自己的DokcerHub仓库下。

比如上传修改后的image到我的elk仓库：saiyn/elk

* 执行`docker container ps`查看elk的CONTAINER ID， 假设为c78ade920bae.
* 执行`docker commit -m "refine index pattern;add one more filebeat input" c78ade920bae saiyn/elk:v1.0.3`生成一个新的image，并且打上tag：v1.0.3
* 执行`docker push saiyn/elk:v1.0.3`将新image推送到dockerHub的elk仓库.


<br />



## docker-compose的应用

<br />

### 重新build并启动某一个service

<br />
在我们更新了ui容器的js代码后，如果只是执行`docker-compose restart ui`会发现网页并没有更新
这时可以依次执行如下命令:

* docker-compose stop ui
* docker-compose build --no-cache ui
* docker-compose up -d --no-deps ui

<br />

---

# docker in Pycharm

<br />

## pycharm in windows

<br />

> requirement: pycharm professional version + windows 10 enterprise

**key step to set docker-compose env for pycharm**

* install docker desktop
* exec `docker pull busybox` in docker desktop to install busybox image
* enable `Expose daemon on tcp://localhost:2375 without tls` in docker desktop setting page
* set Engine API URL to `tcp://localhost::2375` in pycharm FILE->Setting->Build,Execution,Deployment setting page
* Add python Interpreter in pycharm FILE->Setting->Project:xxx ->Docker Compose setting page

> 上面这一步是可以让我们直接在pycharm中调试docker container中的python工程，比如你的docker-compose是搭建一个web server项目，里面构建了7、8个container, 其他一个叫`api`
> 的contaienr可能就是你基于flask构建的web server,这时你在docker compose setting apge中的serice选项中选择api。




## pycharm in ubuntu

<br />

在window上设置Docker的`Expose daemon on tcp://localhost:2375 without TLS`很方便，当时ubuntu上有点免费，查询了各种解决方案，发现使用nmap的ncat工具可以轻松解决问题。

  $sudo ncat -lknvp 2375 -c "ncat -U /var/run/docker.sock"

<br />


# dockerfile for RockyLinux

centos 宣布EOS之后，前centos的创始人基于centos创立了RockyLinux发行版

```
  FROM rockylinux:8

  RUN yum -y groupinstall "Development Tools" && \
      yum -y install tar && \
      yum -y install perl && \
      yum -y install wget && \
      yum -y install expat-devel && \
      yum -y install zlib zlib-devel && \
      yum -y install bison openssl-devel && \
      wget ftp://ftp.gnu.org/gnu/autoconf/autoconf-2.69.tar.gz && \
      tar zxvf autoconf-2.69.tar.gz && \
      cd autoconf-2.69 && \
      ./configure --prefix=/usr/ && \
      make && make install && \
      cd .. && \
      rm -f autoconf-2.69.tar.gz
```


