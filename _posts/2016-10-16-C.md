---
layout: post
title:  "Ｃ开发笔记"
date:   2016-08-07 15:15:54
categories: Diary
excerpt: ffmpeg linux
---

* content
{:toc}


进行Ｃ语言开发３年多了，发现有时候因为对ｃ的基础理解不够深入和全面，导致在开发实际项目中写不出高质量的代码。这篇文章用来记录开发过程中实际需要牢固掌握的基础知识。只有在牢固的基础上才能写出高质量的代码. 


---


## 链接、装载与库


### BFD库

由于现代的硬件和软件平台种类非常繁多，每个平台都有它独特的目标文件格式，即使像ELF这样的同一个格式在不同软硬件平台上都有着不同的变种。种种差异导致编译器和链接器很难处理不同平台之间的目标文件，特别是对于像GCC和binutils这种跨平台的工具来说，最后有一种统一的接口来处理这些不同格式之间的差异。

`Any problem in computer science can be solved by another layer of indirection`－－计算机科学领域的任何问题都可以通过增加一个中间层来解决。

BFD库就是这样一个`another layer`，它是一个GNU项目，目的就是希望通过一种统一的接口来处理不同的目标文件格式。BFD把目标文件抽象成一个统一的模型，充当一个中间层，使得程序只要通过操作这个抽象的目标文件模型就可以实现操作所有BFD支持的目标文件格式。

现在GCC、链接器ld、调试器GDB及binutils的其他工具都通过BFD库来处理目标文件，而不是直接操作目标文件。


---

### 特殊符号

当我们使用`ld`作为链接器来链接产生可执行文件时，它会为我们定义很多特殊的符号，这些特殊符号并没有在你的程序中定义，但是你可以直接使用`extern`进行声明然后使用，我们称之为`特殊符号`。

这些符号是被定义在`ld`链接器的链接脚本中的，链接器会在将程序最终链接成可执行文件的时候将其解析成正确的值，几个具有代表性的特殊符号如下:

> * __executable_start, 该符号为程序起始地址，注意，不是入口地址，是程序的最开始的地址。
> * __etext,该符号为代码段结束地址，即代码段最末尾的地址。
> * _edata,该符号数据段结束地址。
> * _end, 该符号为程序结束地址。	

以上说的地址都为程序被装载时的虚拟地址。测试代码如下:

<pre><code>#include "stdio.h"

extern char __executable_start[];
extern char __etext[];
extern char _edata[];
extern char _end[];


int main()
{
	int i = 0xa5;

	printf("Stack Start %p\n", &i);
	printf("Executable Start %p\n", __executable_start);
	printf("Text End %p\n", __etext);
	printf("Data End %p\n", _edata);
	printf("Executable End %p\n", _end);

	return 0;
}
</code></pre>

运行结果如下:

![special](http://omp8s6jms.bkt.clouddn.com/image/git/special.png)

---

### 动态链接

动态链接技术的实现主要涉及`装载时重定位`和`地址无关代码`两种手段。装载时重定位技术和链接时重定位技术很类似，后者是使用在静态库的链接时。地址无关代码的实现比较复杂，也是重点需要研究的。

> 装载时重定位

为了实现动态链接，我们首先要解决的是共享对象地址的冲突问题，如果不同的模块目标装载地址都一样肯定是不行的，所以早期的时候，通过一种叫做`静态共享库(static shared library)`的方式，就是手动的指定各个模块的地址，比如将0x1000到0x2000分配给模块A,将0x2000到0x3000分配给模块B。显然这种方式有很多问题，如果某个模块被多个程序使用，或者是多个模块被多个程序使用，那么管理这些模块的地址将是一件无比繁琐的事情。另外，静态链接库的升级也很成问题，因为升级后的共享库必须保持共享库中全局函数和变量地址的不变，如果应用程序中在链接时已经绑定了这些地址，一旦更改，就必须重新链接应用程序。

为了解决这个模块装载地址固定的问题，我们设想是否可以让共享对象在`任意地址`加载?这个问题另一种表述方式是:共享对象在编译时不能假设自己在进程虚拟地址空间中的位置。与此不同的是，可执行文件基本可以确定自己在进程虚拟地址空间的起始位置，因为可执行文件往往是第一个被加载的文件，它可以选择一个固定空闲的地址，比如Linux下一般都是`0x08040000`,Windows下一般都是`0x00400000`

为了能够使共享对象在任意地址装载，我们首先会想到可以参照静态链接中的地址重定位方法。基本思路就是，在链接时，对所有绝对地址的引用不作重定位，而把这一步推迟到装载时再完成。假设某个函数func相对于代码段的起始地址的偏移是0x100，当模块装载到0x10000000时，我们假设代码段位于模块的最开始，即代码段的装载地址也是0x1000000，那么我们就可以确定func的地址为0x10001000。这时候，系统遍历模块中的重定位表，把所有func的地址引用都重定位到0x10001000。

但是装载时重定位的方法没有完全解决动态链接中的所有问题，可以想象，动态链接模块被映射至虚拟空间后，指令部分是在多个进程之间共享的，由于装载时重定位的方法需要修改指令，所以没有办法做到同一份指令被多个进程共享，因为不同进行需要进行的重定位肯定是不一致的。这样动态链接库就失去了节省内存的最初目标，但是装载时重定位的共享对象的运行速度要比后面要介绍的使用地址无关代码的共享对象快，因为它省去了地址无关代码中每次访问全局数据和函数时需要做的一次计算当前地址以及间接地址寻址的过程。

编译动态链接库时，如果只是添加`-shared`参数而不加`-fPIC`参数的话，那么输出的共享对象就是使用装载时重定位的方法。


>	地址无关代码




---

## 语法

### 类型提升

在实际的项目里，经常会出现不同类型之间互相赋值的情况。这个时候要特别注意在赋值过程中可能出现的类型提升问题。看下面一个简单的例子：
<pre><code>
#include "stdlib.h"
#include "stdio.h" 

int main()
{
  unsigned int a = 1;
  char  b = 0x8a;
  unsigned char  c = 0x8a;

  a = b;

  printf("%x\n", a);

  a = c;

  printf("%x\n",a);

  return 0;

}
</code></pre>

上面程序运行结果：`0xffffff8a`  `0x8a`

从这个例子可以看出无符号和有符号的变量不能随便混用。

---

<pre><code>int copy_something(char *buf, int len)
｛
	#define MAX_LEM 256
	char mybuf[MAX_LEN];

	...
	...
	if(len > MAX_LEN)
	{
		return -1;
	}

	return memcpy(mybuf,buf,len);
｝
</code></pre>

上面的例子中，如果len传进来的是一个负值，那么会通过if语句的检查，由于memcpy的len的入参类型是unsigned int,所以
会导致传进来的负值变成一个很大的值。



### 整形溢出


---

## 数据结构

### 树

1.Binary Tree的特点是每个结点最多只有两颗子树，即二叉树中不存在度大于２的结点。并且，二叉树的子树有左右之分，其次序不能任意颠倒。

2.






