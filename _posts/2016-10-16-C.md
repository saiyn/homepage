---
layout: post
title:  "Ｃ开发笔记"
date:   2016-08-07 15:15:54
categories: Diary
excerpt: ffmpeg linux
---

* content
{:toc}


进行Ｃ语言开发３年多了，发现有时候因为对ｃ的基础理解不够深入和全面，导致在开发实际项目中写不出高质量的代码。这篇文章用来记录开发过程中实际需要牢固掌握的基础知识。只有在牢固的基础上才能写出高质量的代码. 


---


## 链接、装载与库

### EFL可执行文件

Windows下的PE(Portable Executale)和Linux下的ELF(Executable Linkable Format)都是COFF(Common file format)格式的变种。和可执行文件接近的是目标文件，它是源代码编译后未进行链接的那些中间文件(Linux下的.o),它和可执行文件格式几乎是一样的。同时，动态链接库和静态链接库文件也都是按照ELF格式进行存储的。

粗略的来看，ELF文件就是由`文件头`加各种段构成的。其中我们比较熟悉的段有`.text`段用来存放指令;`.data`段用来存放全局变量和局部静态变量数据;另外一个比较特殊且容易和进程中的段内存分布混淆的段`.bass`段，是用来存放全局为初始化变量和局部静态变量。因为为初始化的全局变量和局部静态变量默认值都为0，本来它们也可以直接放在`.data`段的，但是因为它们都是0，所以为了减小ELF文件的大小，`.bass`段只是为为初始化全局变量和局部静态变量预留位置而已，它并没有内容，所以在文件中不占据空间。但是要清楚，最终程序运行时肯定是要给`.bass`段分配实际内存空间的。

<pre><code>int printf(const char *format, ...);

int global_init_var = 64;
int global_uninit_var;

void func(int i)
{
	printf("%d\n0", i);
}

int main()
{
	static int static_init_var = 85;
	static int static_uninit_var;

	int a = 1;
	int b;

	func(static_init_var + static_uninit_var + a + b);
	
	return 0;
}

</code></pre>

编译上面代码得到`simpleSection.o`目标文件，然后执行`obidump -h simpleSection.o`得到如下:

![section](http://omp8s6jms.bkt.clouddn.com/image/git/section.png)


从上面的结果来看，simpleSection.o的段比我们想象中的要多，除了最基本的代码段、数据段和.bss段外，还有４个段是只读数据段(.rodata)、注释信息段(.comment)、堆栈提示段(.note.GNU-stack)和xx段(.eh_frame)。这个几个特殊的段先不去研究，先看看几个重要的段的属性。其中`size`和`File off`属性分别是段的大小和段在文件中的偏移字节数；第2行中的`CONTENTS`表示该段在文件中存在，所以我们看BSS段没有`CONTENTS`属性。各个段在ELF文件中的结构如下图(图中的段偏移量有出入): 

![sim_pic](http://omp8s6jms.bkt.clouddn.com/image/git/sim_pic.png)

> **ELF文件结构描述** 

![elf_jg](http://omp8s6jms.bkt.clouddn.com/image/git/elf_jg.png)

如上图所示，ELF目标文件格式的最前部是ELF文件头，它包含了描述整个文件的基本属性，比如ELF文件版本、目标机器型号、程序入口地址等。紧接着的是各个段以及与段有关的重要结构--段表，该表描述了ELF文件中包含的所有信息，比如每个段的段名、段的长度、在文件中的偏读写权限以及段的其他属性。最后是一些ELF中的辅助结构，比如字符串表、符号表等。

可以使用`readelf`命令来详细查看ELF文件:

![readelf](http://omp8s6jms.bkt.clouddn.com/image/git/readelf.png)


ELF文件头结构及相关常数定义在`/usr/include/elf.h`里:

![elf_head](http://omp8s6jms.bkt.clouddn.com/image/git/elf_head.png)

从前面readelf输出来看，最前面的`Magic`的16个字节刚好对应上面结构体中的`e_ident`这个成员。这16个字节被用来规定表示ELF文件的平台属性，比如字长(32/64位)、字节序、ELF文件版本。

最开始的4个字节是所有ELF文件都必须相同的标识码，分别为`0x7f`,`0x45`,`0x4c`,`0x46`，第一个字节对应ASCII字符里的DEL控制符，后面3个刚好是`E/L/F`这3个字母的ASCII码。者4个字节又被称为是ELF文件的魔数。这种魔数用来确认文件的类型，操作系统在加载可执行文件时会确认魔数是否正确，如果不正确会拒绝加载。第5个字节用来标示字长的，0x01代表32位，0x02代表64位。第6个字节代表字节序，也就是大小端，第7个字节规定ELF文件的主版本号，一般是1,因为ELF标准自1.2版本之后就再也没有更新了。后面的9个字节为保留位。


---

### 进程虚拟空间分布


---
### 栈与调用惯例


---
### 弱符号与强符号



理解编译器中的弱符号和强符号的定义，对于我们编写多模块代码来说是必须要掌握的。举个项目中实际的例子，我司某个项目中途需要支持自动化测试，实现方式是添加一个我们新开发的测试数据收集分析和转发的模块，这个模块在最终发布程序是肯定是不会链接进工程中的。现在出现一个问题，这个测试模块中定义了一个全局变量如`g_print_level = 16`，主模块需要使用这个变量，但是又不想将这个变量定义在头文件中，这时，如果在主模块中使用`extern　int g_print_level;`的话，那么当编译不含测试代码模块的话，就会出现变量为定义的错误。这时最简单的解决办法是什么？就是取得`extern`修饰符，直接定义`int g_print_level;`原因下面分析。

编译器默认所有函数和初始化了的全局变量为强符号，未初始化的全局变量为弱符号。当然，我们可以通过GCC的`__attribute__(weak)`来定义任何一个强符号为弱符号。另外，特别注意，强符号和弱符号都是针对定义来说的，不是针对符号的引用，不能和强引用弱引用混淆。

链接器按照如下规则处理与选择被多次定义的全局符号:

* 规则1:不允许强符号被多次定义，如果多次定义链接器就会报符号重复定义错误。
* 规则2:如果一个符号在某个目标文件中是强符号，而在另外一个目标文件中都是弱符号，那么选择强符号。
* 规则3:如果一个符号在所有目标文件中都是弱符号，那么选择其中占用空间最大的一个。

通过规则2，我们就可以理解上面的解决方法是正确可行的。


### 弱引用和强引用

一般情况下，在目标文件最终进行链接时，如果存在对外部目标文件的符号引用没有被正确决议，也就是没有找到该符号的定义，那么链接器就会报符号未定义错误，这种就是强引用(Strong Reference)。与之对应的就是弱引用(Weak Reference),在处理弱引用时，如果该符号为被定义，链接器对于该引用不报错，而是默认将其初始化为0，或者是一个特殊的值，以便于程序代码能够识别。

在GCC中，我们可以通过使用`"__attribute__((weakref)"`这个扩展关键字来声明对一个外部函数的引用为弱引用，比如下面的代码:

<pre><code>__attribute__((weakref)) void foo();

int main()
{
	foo();
}
</code></pre>

我们编译通过上面的代码，但是显然运行时会发生错误，所以正确的使用方法如下:

<pre><code>__attribute__((weakref)) void foo();

int main()
{

	if(foo)	foo();
}
</code></pre>



---
### BFD库

由于现代的硬件和软件平台种类非常繁多，每个平台都有它独特的目标文件格式，即使像ELF这样的同一个格式在不同软硬件平台上都有着不同的变种。种种差异导致编译器和链接器很难处理不同平台之间的目标文件，特别是对于像GCC和binutils这种跨平台的工具来说，最后有一种统一的接口来处理这些不同格式之间的差异。

`Any problem in computer science can be solved by another layer of indirection`－－计算机科学领域的任何问题都可以通过增加一个中间层来解决。

BFD库就是这样一个`another layer`，它是一个GNU项目，目的就是希望通过一种统一的接口来处理不同的目标文件格式。BFD把目标文件抽象成一个统一的模型，充当一个中间层，使得程序只要通过操作这个抽象的目标文件模型就可以实现操作所有BFD支持的目标文件格式。

现在GCC、链接器ld、调试器GDB及binutils的其他工具都通过BFD库来处理目标文件，而不是直接操作目标文件。


---

### 特殊符号

当我们使用`ld`作为链接器来链接产生可执行文件时，它会为我们定义很多特殊的符号，这些特殊符号并没有在你的程序中定义，但是你可以直接使用`extern`进行声明然后使用，我们称之为`特殊符号`。

这些符号是被定义在`ld`链接器的链接脚本中的，链接器会在将程序最终链接成可执行文件的时候将其解析成正确的值，几个具有代表性的特殊符号如下:

* __executable_start, 该符号为程序起始地址，注意，不是入口地址，是程序的最开始的地址。
* __etext,该符号为代码段结束地址，即代码段最末尾的地址。
* _edata,该符号数据段结束地址。
* _end, 该符号为程序结束地址。	

以上说的地址都为程序被装载时的虚拟地址。测试代码如下:

<pre><code>#include "stdio.h"

extern char __executable_start[];
extern char __etext[];
extern char _edata[];
extern char _end[];


int main()
{
	int i = 0xa5;

	printf("Stack Start %p\n", &i);
	printf("Executable Start %p\n", __executable_start);
	printf("Text End %p\n", __etext);
	printf("Data End %p\n", _edata);
	printf("Executable End %p\n", _end);

	return 0;
}
</code></pre>

运行结果如下:

![special](http://omp8s6jms.bkt.clouddn.com/image/git/special.png)

---

### 动态链接

动态链接技术的实现主要涉及`装载时重定位`和`地址无关代码`两种手段。装载时重定位技术和链接时重定位技术很类似，后者是使用在静态库的链接时。地址无关代码的实现比较复杂，也是重点需要研究的。

> **装载时重定位**

为了实现动态链接，我们首先要解决的是共享对象地址的冲突问题，如果不同的模块目标装载地址都一样肯定是不行的，所以早期的时候，通过一种叫做`静态共享库(static shared library)`的方式，就是手动的指定各个模块的地址，比如将0x1000到0x2000分配给模块A,将0x2000到0x3000分配给模块B。显然这种方式有很多问题，如果某个模块被多个程序使用，或者是多个模块被多个程序使用，那么管理这些模块的地址将是一件无比繁琐的事情。另外，静态链接库的升级也很成问题，因为升级后的共享库必须保持共享库中全局函数和变量地址的不变，如果应用程序中在链接时已经绑定了这些地址，一旦更改，就必须重新链接应用程序。

为了解决这个模块装载地址固定的问题，我们设想是否可以让共享对象在`任意地址`加载?这个问题另一种表述方式是:共享对象在编译时不能假设自己在进程虚拟地址空间中的位置。与此不同的是，可执行文件基本可以确定自己在进程虚拟地址空间的起始位置，因为可执行文件往往是第一个被加载的文件，它可以选择一个固定空闲的地址，比如Linux下一般都是`0x08040000`,Windows下一般都是`0x00400000`

为了能够使共享对象在任意地址装载，我们首先会想到可以参照静态链接中的地址重定位方法。基本思路就是，在链接时，对所有绝对地址的引用不作重定位，而把这一步推迟到装载时再完成。假设某个函数func相对于代码段的起始地址的偏移是0x100，当模块装载到0x10000000时，我们假设代码段位于模块的最开始，即代码段的装载地址也是0x1000000，那么我们就可以确定func的地址为0x10001000。这时候，系统遍历模块中的重定位表，把所有func的地址引用都重定位到0x10001000。

但是装载时重定位的方法没有完全解决动态链接中的所有问题，可以想象，动态链接模块被映射至虚拟空间后，指令部分是在多个进程之间共享的，由于装载时重定位的方法需要修改指令，所以没有办法做到同一份指令被多个进程共享，因为不同进行需要进行的重定位肯定是不一致的。这样动态链接库就失去了节省内存的最初目标，但是装载时重定位的共享对象的运行速度要比后面要介绍的使用地址无关代码的共享对象快，因为它省去了地址无关代码中每次访问全局数据和函数时需要做的一次计算当前地址以及间接地址寻址的过程。

编译动态链接库时，如果只是添加`-shared`参数而不加`-fPIC`参数的话，那么输出的共享对象就是使用装载时重定位的方法。


> **地址无关代码**

地址无关代码(PIC,Position-independent Code)技术的基本思想就是，将需要在装载时动态计算修改的共享指令(全局变量、API函数)部分分离出来，和数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。

程序中共享对象的地址引用按照是否为夸模块分成两类，模块内的引用和模块间的引用；按照不同的引用方式又可以分为指令引用和数据访问。这样就可以将程序中的共享对象地址引用分成4类：

* 第一种是模块内部的函数调用、跳转等。
* 第二种是模块内部数据的访问，比如模块中定义的全局变量、静态变量。
* 第三种是模块外部的函数调用、跳转等。
* 第四种是模块外部的数据访问，比如其他模块中定义的全局变量。

实例代码如下:

<pre><code>static int a;
extern int b;
extern void  func();

void bar()
{
	a = 1;
	b = 2;
}

void foo()
{
	bar();
	func();
}
</code></pre>

显然，变量`a`就是第二种类型；变量`b`是第四种类型;函数`func()`的调用是第三种类型;函数`bar()`的调用是第一种类型。

> 注:当编译器在编译上面代码时，它实际上不能确定变量`b`和函数`func()`是模块外部还是内部的，因为它们有可能被定义在一个共享对象的其他目标文件中。由于无法确定，编译器只能把它们都当作模块外部的函数和变量来处理。

执行`gcc -shared -fPIC -o lib.so simpleSection.c`编译上面代码得到`lib.so`，然后执行`objdump -d lib.so`查看汇编
代码，结合汇编代码来阐述上面四种情况。


**类型一　模块内部调用或跳转**

上面这四种情况中，第一种类型应该是最简单的，因为被调用的函数与调用者处于同一个模块，它们之间的相对位置是
固定的，所以这种情况比较简单。对于现代的系统来讲，模块内部的跳转、函数调用都可以是`相对地址调用`或者是
基于寄存器的相对调用，所以对于这种指令是不需要重定位的。比如上面例子中`foo`对`bar`的调用代码如下:

![dis_coed](http://omp8s6jms.bkt.clouddn.com/image/git/dis_cod.png)

上面指令前两条很简单，就是函数调用通用流程，保存上次的帧指针(Frame Pointer)然后更新当前的帧指针为当前的栈顶指针。
第3条就是`foo`对`bar`的调用指令，其实是一条相对地址调用指令，第一个字节码`e8`是相对地址调用指令callq的指令码，后面的`a9 fe ff ff`是目的地址相对于下一条指令的偏移。由于我的笔记本处理器是小端模式，所以这个偏移实际是`0xfffffea9`,它是`-0x157`的补码，下一条指令地址是`0x717`,所以`bar`的地址是`0x717 - 0x157` = `0x5c0`，那么只要`bar`和`foo`的相对位置不变，这条指令就是`地址无关的`,即无论模块被装载到哪个位置，这条指令都是有效的。这种相对地址的方式对于`jmp`指令也是有效的。

> 注:这里存在2个问题，一个是上面的`0x5c0`其实是`bar@plt`地址，至于这个地址的具体含义在下面章节中会说明。第二个问题是，上面的方式存在一个叫做共享对象`全局符号介入(Global Symbol Interposition)`的问题，这个也会在后面章节说明。

**类型二　模块内部数据访问**



---

### 延时绑定(PLT)




---

## 语法

### 类型提升

在实际的项目里，经常会出现不同类型之间互相赋值的情况。这个时候要特别注意在赋值过程中可能出现的类型提升问题。看下面一个简单的例子：
<pre><code>
#include "stdlib.h"
#include "stdio.h" 

int main()
{
  unsigned int a = 1;
  char  b = 0x8a;
  unsigned char  c = 0x8a;

  a = b;

  printf("%x\n", a);

  a = c;

  printf("%x\n",a);

  return 0;

}
</code></pre>

上面程序运行结果：`0xffffff8a`  `0x8a`

从这个例子可以看出无符号和有符号的变量不能随便混用。

---

<pre><code>int copy_something(char *buf, int len)
｛
	#define MAX_LEM 256
	char mybuf[MAX_LEN];

	...
	...
	if(len > MAX_LEN)
	{
		return -1;
	}

	return memcpy(mybuf,buf,len);
｝
</code></pre>

上面的例子中，如果len传进来的是一个负值，那么会通过if语句的检查，由于memcpy的len的入参类型是unsigned int,所以
会导致传进来的负值变成一个很大的值。



### 整形溢出


---

## 数据结构

### 树

1.Binary Tree的特点是每个结点最多只有两颗子树，即二叉树中不存在度大于２的结点。并且，二叉树的子树有左右之分，其次序不能任意颠倒。

2.






