---
layout: post
title:  "Ｃ开发笔记"
date:   2016-08-07 15:15:54
categories: Diary
excerpt: ffmpeg linux
---

* content
{:toc}


进行Ｃ语言开发３年多了，发现有时候因为对ｃ的基础理解不够深入和全面，导致在开发实际项目中写不出高质量的代码。这篇文章用来记录开发过程中实际需要牢固掌握的基础知识。只有在牢固的基础上才能写出高质量的代码. 


---


## 链接、装载与库

### 弱符号与强符号


理解编译器中的弱符号和强符号的定义，对于我们编写多模块代码来说是必须要掌握的。举个项目中实际的例子，我司某个项目中途需要支持自动化测试，实现方式是添加一个我们新开发的测试数据收集分析和转发的模块，这个模块在最终发布程序是肯定是不会链接进工程中的。现在出现一个问题，这个测试模块中定义了一个全局变量如`g_print_level = 16`，主模块需要使用这个变量，但是又不想将这个变量定义在头文件中，这时，如果在主模块中使用`extern　int g_print_level;`的话，那么当编译不含测试代码模块的话，就会出现变量为定义的错误。这时最简单的解决办法是什么？就是取得`extern`修饰符，直接定义`int g_print_level;`原因下面分析。

编译器默认所有函数和初始化了的全局变量为强符号，未初始化的全局变量为弱符号。当然，我们可以通过GCC的`__attribute__(weak)`来定义任何一个强符号为弱符号。另外，特别注意，强符号和弱符号都是针对定义来说的，不是针对符号的引用，不能和强引用弱引用混淆。

链接器按照如下规则处理与选择被多次定义的全局符号:

* 规则1:不允许强符号被多次定义，如果多次定义链接器就会报符号重复定义错误。
* 规则2:如果一个符号在某个目标文件中是强符号，而在另外一个目标文件中都是弱符号，那么选择强符号。
* 规则3:如果一个符号在所有目标文件中都是弱符号，那么选择其中占用空间最大的一个。

通过规则2，我们就可以理解上面的解决方法是正确可行的。


### 弱引用和强引用




---
### BFD库

由于现代的硬件和软件平台种类非常繁多，每个平台都有它独特的目标文件格式，即使像ELF这样的同一个格式在不同软硬件平台上都有着不同的变种。种种差异导致编译器和链接器很难处理不同平台之间的目标文件，特别是对于像GCC和binutils这种跨平台的工具来说，最后有一种统一的接口来处理这些不同格式之间的差异。

`Any problem in computer science can be solved by another layer of indirection`－－计算机科学领域的任何问题都可以通过增加一个中间层来解决。

BFD库就是这样一个`another layer`，它是一个GNU项目，目的就是希望通过一种统一的接口来处理不同的目标文件格式。BFD把目标文件抽象成一个统一的模型，充当一个中间层，使得程序只要通过操作这个抽象的目标文件模型就可以实现操作所有BFD支持的目标文件格式。

现在GCC、链接器ld、调试器GDB及binutils的其他工具都通过BFD库来处理目标文件，而不是直接操作目标文件。


---

### 特殊符号

当我们使用`ld`作为链接器来链接产生可执行文件时，它会为我们定义很多特殊的符号，这些特殊符号并没有在你的程序中定义，但是你可以直接使用`extern`进行声明然后使用，我们称之为`特殊符号`。

这些符号是被定义在`ld`链接器的链接脚本中的，链接器会在将程序最终链接成可执行文件的时候将其解析成正确的值，几个具有代表性的特殊符号如下:

* __executable_start, 该符号为程序起始地址，注意，不是入口地址，是程序的最开始的地址。
* __etext,该符号为代码段结束地址，即代码段最末尾的地址。
* _edata,该符号数据段结束地址。
* _end, 该符号为程序结束地址。	

以上说的地址都为程序被装载时的虚拟地址。测试代码如下:

<pre><code>#include "stdio.h"

extern char __executable_start[];
extern char __etext[];
extern char _edata[];
extern char _end[];


int main()
{
	int i = 0xa5;

	printf("Stack Start %p\n", &i);
	printf("Executable Start %p\n", __executable_start);
	printf("Text End %p\n", __etext);
	printf("Data End %p\n", _edata);
	printf("Executable End %p\n", _end);

	return 0;
}
</code></pre>

运行结果如下:

![special](http://omp8s6jms.bkt.clouddn.com/image/git/special.png)

---

### 动态链接

动态链接技术的实现主要涉及`装载时重定位`和`地址无关代码`两种手段。装载时重定位技术和链接时重定位技术很类似，后者是使用在静态库的链接时。地址无关代码的实现比较复杂，也是重点需要研究的。

> **装载时重定位**

为了实现动态链接，我们首先要解决的是共享对象地址的冲突问题，如果不同的模块目标装载地址都一样肯定是不行的，所以早期的时候，通过一种叫做`静态共享库(static shared library)`的方式，就是手动的指定各个模块的地址，比如将0x1000到0x2000分配给模块A,将0x2000到0x3000分配给模块B。显然这种方式有很多问题，如果某个模块被多个程序使用，或者是多个模块被多个程序使用，那么管理这些模块的地址将是一件无比繁琐的事情。另外，静态链接库的升级也很成问题，因为升级后的共享库必须保持共享库中全局函数和变量地址的不变，如果应用程序中在链接时已经绑定了这些地址，一旦更改，就必须重新链接应用程序。

为了解决这个模块装载地址固定的问题，我们设想是否可以让共享对象在`任意地址`加载?这个问题另一种表述方式是:共享对象在编译时不能假设自己在进程虚拟地址空间中的位置。与此不同的是，可执行文件基本可以确定自己在进程虚拟地址空间的起始位置，因为可执行文件往往是第一个被加载的文件，它可以选择一个固定空闲的地址，比如Linux下一般都是`0x08040000`,Windows下一般都是`0x00400000`

为了能够使共享对象在任意地址装载，我们首先会想到可以参照静态链接中的地址重定位方法。基本思路就是，在链接时，对所有绝对地址的引用不作重定位，而把这一步推迟到装载时再完成。假设某个函数func相对于代码段的起始地址的偏移是0x100，当模块装载到0x10000000时，我们假设代码段位于模块的最开始，即代码段的装载地址也是0x1000000，那么我们就可以确定func的地址为0x10001000。这时候，系统遍历模块中的重定位表，把所有func的地址引用都重定位到0x10001000。

但是装载时重定位的方法没有完全解决动态链接中的所有问题，可以想象，动态链接模块被映射至虚拟空间后，指令部分是在多个进程之间共享的，由于装载时重定位的方法需要修改指令，所以没有办法做到同一份指令被多个进程共享，因为不同进行需要进行的重定位肯定是不一致的。这样动态链接库就失去了节省内存的最初目标，但是装载时重定位的共享对象的运行速度要比后面要介绍的使用地址无关代码的共享对象快，因为它省去了地址无关代码中每次访问全局数据和函数时需要做的一次计算当前地址以及间接地址寻址的过程。

编译动态链接库时，如果只是添加`-shared`参数而不加`-fPIC`参数的话，那么输出的共享对象就是使用装载时重定位的方法。


> **地址无关代码**

地址无关代码(PIC,Position-independent Code)技术的基本思想就是，将需要在装载时动态计算修改的共享指令(全局变量、API函数)部分分离出来，和数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。

程序中共享对象的地址引用按照是否为夸模块分成两类，模块内的引用和模块间的引用；按照不同的引用方式又可以分为指令引用和数据访问。这样就可以将程序中的共享对象地址引用分成4类：

	* 第一种是模块内部的函数调用、跳转等。
	* 第二种是模块内部数据的访问，比如模块中定义的全局变量、静态变量。
	* 第三种是模块外部的函数调用、跳转等。
	* 第四种是模块外部的数据访问，比如其他模块中定义的全局变量。

实例代码如下:

<pre><code>static int a;
extern int b;
extern void  func();

void bar()
{
	a = 1;
	b = 2;
}

void foo()
{
	bar();
	func();
}
</code></pre>

显然，变量`a`就是第二种类型；变量`b`是第四种类型;函数`func()`的调用是第三种类型;函数`bar()`的调用是第一种类型。

> 注:当编译器在编译上面代码时，它实际上不能确定变量`b`和函数`func()`是模块外部还是内部的，因为它们有可能被定义在一个共享对象的其他目标文件中。由于无法确定，编译器只能把它们都当作模块外部的函数和变量来处理。









---

## 语法

### 类型提升

在实际的项目里，经常会出现不同类型之间互相赋值的情况。这个时候要特别注意在赋值过程中可能出现的类型提升问题。看下面一个简单的例子：
<pre><code>
#include "stdlib.h"
#include "stdio.h" 

int main()
{
  unsigned int a = 1;
  char  b = 0x8a;
  unsigned char  c = 0x8a;

  a = b;

  printf("%x\n", a);

  a = c;

  printf("%x\n",a);

  return 0;

}
</code></pre>

上面程序运行结果：`0xffffff8a`  `0x8a`

从这个例子可以看出无符号和有符号的变量不能随便混用。

---

<pre><code>int copy_something(char *buf, int len)
｛
	#define MAX_LEM 256
	char mybuf[MAX_LEN];

	...
	...
	if(len > MAX_LEN)
	{
		return -1;
	}

	return memcpy(mybuf,buf,len);
｝
</code></pre>

上面的例子中，如果len传进来的是一个负值，那么会通过if语句的检查，由于memcpy的len的入参类型是unsigned int,所以
会导致传进来的负值变成一个很大的值。



### 整形溢出


---

## 数据结构

### 树

1.Binary Tree的特点是每个结点最多只有两颗子树，即二叉树中不存在度大于２的结点。并且，二叉树的子树有左右之分，其次序不能任意颠倒。

2.






