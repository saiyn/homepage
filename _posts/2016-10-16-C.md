---
layout: post
title:  "Ｃ开发笔记"
date:   2016-08-07 15:15:54
categories: Diary
excerpt: ffmpeg linux
---

* content
{:toc}

	进行Ｃ语言开发３年多了，发现有时候因为对ｃ的基础理解不够深入和全面，导致在开发实际项目中写不出高质量的代码。这篇文章用来记录开发过程中实际需要牢固掌握的基础知识。
	只有在牢固的基础上才能写出高质量的代码. 


---


## 链接、装载与库

### BFD库

由于现代的硬件和软件平台种类非常繁多，每个平台都有它独特的目标文件格式，即使像ELF这样的同一个格式在不同软硬件平台上都有着不同的变种。种种差异导致编译器和链接器很难处理不同平台之间的目标文件，特别是对于像GCC和binutils这种跨平台的工具来说，最后有一种统一的接口来处理这些不同格式之间的差异。

`Any problem in computer science can be solved by another layer of indirection`－－计算机科学领域的任何问题都可以通过增加一个中间层来解决。

BFD库就是这样一个`another layer`，它是一个GNU项目，目的就是希望通过一种统一的接口来处理不同的目标文件格式。BFD把目标文件抽象成一个统一的模型，充当一个中间层，使得程序只要通过操作这个抽象的目标文件模型就可以实现操作所有BFD支持的目标文件格式。

现在GCC、链接器ld、调试器GDB及binutils的其他工具都通过BFD库来处理目标文件，而不是直接操作目标文件。




### 特殊符号

	当我们使用`ld`作为链接器来链接产生可执行文件时，它会为我们定义很多特殊的符号，这些特殊符号并没有在你的程序中定义，但是你可以直接使用`extern`进行声明然后使用，我们称之为`特殊符号`。

	这些符号是被定义在`ld`链接器的链接脚本中的，链接器会在将程序最终链接成可执行文件的时候将其解析成正确的值，几个具有代表性的特殊符号如下:

> * __executable_start, 该符号为程序起始地址，注意，不是入口地址，是程序的最开始的地址。
> * __etext,该符号为代码段结束地址，即代码段最末尾的地址。
> * _edata,该符号数据段结束地址。
> * _end, 该符号为程序结束地址。	

以上说的地址都为程序被装载时的虚拟地址。测试代码如下:

<pre><code>#include "stdio.h"

extern char __executable_start[];
extern char __etext[];
extern char _edata[];
extern char _end[];


int main()
{
	int i = 0xa5;

	printf("Stack Start %p\n", &i);
	printf("Executable Start %p\n", __executable_start);
	printf("Text End %p\n", __etext);
	printf("Data End %p\n", _edata);
	printf("Executable End %p\n", _end);

	return 0;
}
</code></pre>

运行结果如下:

![special](http://omp8s6jms.bkt.clouddn.com/image/git/special.png)

---

## 语法

### 类型提升

在实际的项目里，经常会出现不同类型之间互相赋值的情况。这个时候要特别注意在赋值过程中可能出现的类型提升问题。看下面一个简单的例子：
<pre><code>
#include "stdlib.h"
#include "stdio.h" 

int main()
{
  unsigned int a = 1;
  char  b = 0x8a;
  unsigned char  c = 0x8a;

  a = b;

  printf("%x\n", a);

  a = c;

  printf("%x\n",a);

  return 0;

}
</code></pre>

上面程序运行结果：`0xffffff8a`  `0x8a`

从这个例子可以看出无符号和有符号的变量不能随便混用。

---

<pre><code>int copy_something(char *buf, int len)
｛
	#define MAX_LEM 256
	char mybuf[MAX_LEN];

	...
	...
	if(len > MAX_LEN)
	{
		return -1;
	}

	return memcpy(mybuf,buf,len);
｝
</code></pre>

上面的例子中，如果len传进来的是一个负值，那么会通过if语句的检查，由于memcpy的len的入参类型是unsigned int,所以
会导致传进来的负值变成一个很大的值。



### 整形溢出


---

## 数据结构

### 树

1.Binary Tree的特点是每个结点最多只有两颗子树，即二叉树中不存在度大于２的结点。并且，二叉树的子树有左右之分，其次序不能任意颠倒。

2.






